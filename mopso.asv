function mopso(seed, func_name, MaxIt, It_no)
disp(['MOPSO:', func_name, '-', num2str(It_no)])

% Problem Definition
[CostFunction, nVar, VarMax, VarMin, true_pf] = Problems(func_name);
VarSize=[1 nVar]; 

% MOPSO Parameters
nPop = 100;
nRep = 1
if contains(func_name, 'zdt')
    nPop=50;            % Population Size
    nRep=50;            % Repository Size
else
    nPop=100;
    nRep=100;
end

w=0.5;              % Inertia Weight
wdamp=0.99;         % Intertia Weight Damping Rate
c1=1;               % Personal Learning Coefficient
c2=2;               % Global Learning Coefficient

nGrid=50;            % Number of Grids per Dimension

alpha=0.1;          % Inflation Rate

beta=2;             % Leader Selection Pressure
gamma=2;            % Deletion Selection Pressure

mu=0.4;             % Mutation Rate

% random seed
rng(seed, 'twister')

%% Initialization
empty_particle.Position=[];
empty_particle.Velocity=[];
empty_particle.Cost=[];
empty_particle.CV=[];  % constraint violation
empty_particle.Best.Position=[];
empty_particle.Best.Cost=[];
empty_particle.IsDominated=[];
empty_particle.GridIndex=[];
empty_particle.GridSubIndex=[];
empty_particle.TargetRegionFlag=[];

pop=repmat(empty_particle,nPop,1);

for i=1:nPop
    
    pop(i).Position=unifrnd(VarMin,VarMax,VarSize);
    
    pop(i).Velocity=zeros(VarSize);
    
    [pop(i).Cost, pop(i).CV]=CostFunction(pop(i).Position);
        
    % Update Personal Best
    pop(i).Best.Position=pop(i).Position;
    pop(i).Best.Cost=pop(i).Cost;
    pop(i).Best.CV=pop(i).CV;
    
end
% relax constraints and make all solutions feasible
Epsilon = max([pop.CV], [], 2);
Epsilon0 = Epsilon;
% Determine Domination
pop=DetermineDomination(pop, Epsilon);

rep=pop(~[pop.IsDominated]);

Grid=CreateGrid(rep,nGrid,alpha);

for i=1:numel(rep)
    rep(i)=FindGridIndex(rep(i),Grid);
end


%% MOPSO Main Loop
for it=1:MaxIt
    disp(['It-', num2str(it)])
    for i=1:nPop

        leader=SelectLeader_mopso(rep,beta);
        
        pop(i).Velocity = w*pop(i).Velocity ...
            +c1*rand(VarSize).*(pop(i).Best.Position-pop(i).Position) ...
            +c2*rand(VarSize).*(leader.Position-pop(i).Position);
        
        pop(i).Position = pop(i).Position + pop(i).Velocity;
        
        % make solution feasible
        pop(i).Position = max(pop(i).Position, VarMin);
        pop(i).Position = min(pop(i).Position, VarMax);
                
        [pop(i).Cost, pop(i).CV] = CostFunction(pop(i).Position);
        
        % Apply Mutation
        pm=(1-(it-1)/(MaxIt-1))^(1/mu);
        if rand<pm
            NewSol.Position=Mutate(pop(i).Position,pm,VarMin,VarMax);
            
            % make solution feasible
            NewSol.Position = max(NewSol.Position, VarMin);
            NewSol.Position = min(NewSol.Position, VarMax);
            
            [NewSol.Cost, NewSol.CV]=CostFunction(NewSol.Position);
            
            if EpsilonDominates(NewSol,pop(i), Epsilon)
                pop(i).Position=NewSol.Position;
                pop(i).Cost=NewSol.Cost;
                pop(i).CV=NewSol.CV;

            elseif EpsilonDominates(pop(i),NewSol, Epsilon)
                % Do Nothing

            else
                if rand<0.5
                    pop(i).Position=NewSol.Position;
                    pop(i).Cost=NewSol.Cost;
                    pop(i).CV=NewSol.CV;
                end
            end
        end
        
        if EpsilonDominates(pop(i),pop(i).Best, Epsilon)
            pop(i).Best.Position=pop(i).Position;
            pop(i).Best.Cost=pop(i).Cost;
            pop(i).Best.CV=pop(i).CV;
            
        elseif EpsilonDominates(pop(i).Best,pop(i), Epsilon)
            % Do Nothing
            
        else
            if rand<0.5
                pop(i).Best.Position=pop(i).Position;
                pop(i).Best.Cost=pop(i).Cost;
                pop(i).Best.CV=pop(i).CV;
            end
        end
        
    end
    
%     % 每隔20代进行一次反向学习
%     if mod(it, 5) == 0
%         
%         for i = 1 : nPop
%             OblSol.Position = obl(pop(i).Position, VarMin, VarMax);
%             OblSol.Cost = CostFunction(OblSol.Position);
%             if Dominates(OblSol,pop(i))
%                 pop(i).Position=OblSol.Position;
%                 pop(i).Cost=OblSol.Cost;
%             end
%             if Dominates(pop(i),pop(i).Best)
%                 pop(i).Best.Position=pop(i).Position;
%                 pop(i).Best.Cost=pop(i).Cost;
%             end
%         end
%     end
    
    % update pop---------------------------------------------
    pop=DetermineDomination(pop, Epsilon); % 这是自己加的，这一行原代码中没有
    % update pop---------------------------------------------
    
    % Add Non-Dominated Particles to REPOSITORY
    rep=[rep
         pop(~[pop.IsDominated])]; %#ok
    
    % Determine Domination of New Resository Members
    rep=DetermineDomination(rep, Epsilon);
    
    % Keep only Non-Dminated Memebrs in the Repository
    rep=rep(~[rep.IsDominated]);
    
    % Update Grid
    Grid=CreateGrid(rep,nGrid,alpha);

    % Update Grid Indices
    for i=1:numel(rep)
        rep(i)=FindGridIndex(rep(i),Grid);
    end
    
    % Check if Repository is Full
    if numel(rep)>nRep
        
        Extra=numel(rep)-nRep;
        for e=1:Extra
            rep=DeleteOneRepMemebr(rep,gamma);
        end
        
    end
   
%     % plot
%     figure(1)
%     PlotConstraints(rep);
%     hold off;
%     pause(0.1)
    
%     % Plot Costs
%     figure(1);
%     PlotCosts_mopso(pop,rep);
%     PlotPareto_mopso(rep, func_name, true_pf);

%     figure(1)
%     PlotPareto(rep, func_name, true_pf, 'mopso');
%     PlotTargetRegion(TargetRegion);
    
    % Damping Inertia Weight
    w=w*wdamp;
    Epsilon = Epsilon * 0.95;
%     Epsilon = Epsilon * (1 - it / 100);
    
end

% % Calculate Indicators
% hv = HyperVolume(rep, func_name);
% gd = GenerationalDistance(rep, true_pf);
% sp = spacing(rep);
% d = delta(rep, true_pf);
% rep = GetTargetRegionFlag(rep, TargetRegion);
% t_rep = rep([rep.TargetRegionFlag] == 1);
% t_hv = HyperVolume(t_rep, func_name);
% t_gd = GenerationalDistance(t_rep, true_pf);
% 
% % Output
% mopso_indicators.iter = it;
% mopso_indicators.hv = hv;
% mopso_indicators.gd = gd;
% mopso_indicators.sp = sp;
% mopso_indicators.delta = d;
% mopso_indicators.rep = rep;
% mopso_indicators.t_rep = t_rep;
% mopso_indicators.t_hv = t_hv;
% mopso_indicators.t_gd = t_gd;
% Output
mopso_indicators.iter = 0;
mopso_indicators.hv = 0;
mopso_indicators.gd = 0;
mopso_indicators.sp = 0;
mopso_indicators.delta = 0;
mopso_indicators.rep = 0;
mopso_indicators.t_rep = 0;
mopso_indicators.t_hv = 0;
mopso_indicators.t_gd = 0;

h = figure;
PlotConstraints(rep);
hold off;

path = ['figure_20200227/', 'CTP6_wdamp095'];
if ~exist(path,'dir')
    mkdir(path);
end

filename = [path, '/', func_name, '-', num2str(It_no)];
saveas(h, filename, 'png');
% 
% % Display
% disp(['it=', num2str(it), ' hv=', num2str(hv, '%.4f'),...
%     ' gd=', num2str(gd, '%.4f'), ' sp=', num2str(sp, '%.4f'),...
%     ' delta=', num2str(d, '%.4f'),...
%     ])
% disp(['t_hv=', num2str(t_hv, '%.4f'), ' t_gd=', num2str(t_gd, '%.4f'),...
%     ' num=', num2str(numel(t_rep))])
end

